# Remediation Engine Documentation

## Overview
The Remediation Engine executes security fixes based on plans generated by the Decision Engine. It implements safety-first principles with automatic rollback, verification, and audit logging.

## Architecture

### Core Components
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ Remediation │ │ Service-Specific│ │ Mock AWS │
│ Orchestrator │────│ Remediation │────│ SDK │
└─────────────────┘ └─────────────────┘ └─────────────────┘
│ │ │
▼ ▼ ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ Rollback │ │ Verification │ │ Intent Logs │
│ Engine │ │ Logic │ └─────────────────┘
└─────────────────┘ └─────────────────┘


### Safety Features
1. **Dry-Run Mode**: Default mode, logs intent without execution
2. **Automatic Rollback**: Failed remediations trigger rollback
3. **Verification**: Post-remediation state verification
4. **Circuit Breakers**: Failure thresholds stop auto-remediation
5. **Least Privilege**: Service-specific IAM roles

## Service-Specific Remediation

### S3 Remediation
**Supported Actions**:
- `ENABLE_S3_PUBLIC_ACCESS_BLOCK`: Enables all public access blocking options
- `PUT_BUCKET_ENCRYPTION`: Enables default bucket encryption

**API Calls**:
- `s3:PutPublicAccessBlock`
- `s3:PutBucketEncryption`
- `s3:GetPublicAccessBlock` (verification)

**Rollback Strategy**:
- Store original public access block configuration
- Restore original configuration on failure

### IAM Remediation
**Supported Actions**:
- `DETACH_IAM_POLICY`: Detaches over-permissive policies from roles/users
- `DEACTIVATE_IAM_ACCESS_KEY`: Deactivates unused access keys

**API Calls**:
- `iam:DetachRolePolicy`, `iam:DetachUserPolicy`
- `iam:AttachRolePolicy`, `iam:AttachUserPolicy` (rollback)
- `iam:UpdateAccessKey`

**Safety Notes**:
- Always requires approval for MVP
- Never modifies IAM policies, only detaches
- Rollback re-attaches the same policy

### Security Group Remediation
**Supported Actions**:
- `REVOKE_SECURITY_GROUP_INGRESS`: Removes overly permissive ingress rules

**API Calls**:
- `ec2:RevokeSecurityGroupIngress`
- `ec2:AuthorizeSecurityGroupIngress` (rollback)

**Rule Matching**:
- Targets 0.0.0.0/0 CIDR on sensitive ports (22, 3389, 3306, 5432)
- Supports both specific ports and port ranges

## Execution Flow

### 1. Plan Validation
```python
# Check if remediator exists for resource type
remediator = orchestrator.get_remediator(finding)
if not remediator:
    raise NoRemediatorError()


    # Execute with safety wrapper
success, result, rollback_result = remediator.safe_execute(plan)

# Verify remediation succeeded
if not remediator._verify_remediation(plan, result):
    raise VerificationError()

    if not success and plan.rollback_calls:
    rollback_result = remediator.execute_rollback(plan)

    # Update finding state
if success:
    finding.state = FindingState.REMEDIATED
else:
    finding.state = FindingState.FAILED
    if rollback_result:
        finding.state = FindingState.ROLLED_BACK

        # Safety controls
DRY_RUN_MODE=true  # Default to safe mode
ENABLED_RULES='["S3-PUBLIC-ACCESS-001"]'

# AWS configuration (for production)
AWS_REGION=us-east-1
FINDINGS_TABLE_NAME=nebulashield-findings


# src/remediation/handler.py
def lambda_handler(event, context):
    # Parse remediation plan from EventBridge event
    plan_data = event.get("detail", event)
    
    # Initialize with environment settings
    dry_run = os.getenv("DRY_RUN_MODE", "true").lower() == "true"
    orchestrator = RemediationOrchestrator(dry_run=dry_run)
    
    # Execute remediation
    success, result, plan = orchestrator.remediate(finding)

 Testing
Unit Tests
    python tests/unit/test_remediation.py

    Simulation Tests
    # Dry-run simulation (safe)
python simulation/remediation_simulator.py --mode=dry_run

# Execute simulation (simulates production)
python simulation/remediation_simulator.py --mode=execute

# Specific scenarios
python simulation/remediation_simulator.py --scenario=s3
python simulation/remediation_simulator.py --scenario=mixed
python simulation/remediation_simulator.py --scenario=failure

Integration Tests

# Full pipeline test
python simulation/full_integration.py --mode=dry_run

Error Handling
Graceful Degradation
Remediation Failure: Execute rollback, mark as FAILED

Rollback Failure: Alert, manual intervention required

Verification Failure: Treat as remediation failure

Network/Timeout: Retry with exponential backoff

Circuit Breakers
Maximum 10 remediations per minute

Stop auto-remediation if failure rate > 20%

Alert when circuit breaker trips

Monitoring
CloudWatch metrics for success/failure rates

SNS alerts for critical failures

Detailed logs with correlation IDs

Deployment Strategy
Phase 1: Dry-Run Only
All remediations run in dry-run mode

Log intent but don't execute

Validate IAM permissions and event flows

Phase 2: Low-Risk Auto-Remediation
Enable S3 public access block auto-remediation

Monitor success rates closely

Keep IAM and Security Group in approval mode

Phase 3: Full Auto-Remediation
Enable all low-risk auto-remediations

Maintain approval for high-risk changes

Implement circuit breakers

Phase 4: Approval Workflow
Add UI/CLI for approving high-risk remediations

Implement approval audit trail

Add scheduled approval expiration

Security Considerations
IAM Security
Remediation roles have service-specific permissions

Explicit deny on iam:* and organizations:*

No permission boundary expansion

Regular permission audits

Data Protection
All audit logs encrypted at rest

No sensitive data in logs

Secure parameter storage (SSM Parameter Store)

Network Security
VPC endpoints for AWS services

Private subnets for Lambdas (future)

Security group ingress/egress restrictions

Performance
Lambda Configuration
Memory: 256MB for S3/IAM, 512MB for batch operations

Timeout: 30 seconds for simple remediations, 60 for batch

Concurrency: 10 concurrent executions max

Optimization
Cache frequently accessed configurations

Batch operations where possible

Async execution for non-critical remediations

Future Enhancements
Phase 2
Multi-Account Support: AWS Organizations integration

Custom Remediations: User-defined remediation scripts

Scheduled Remediations: Off-hours execution

Compliance Reporting: SOC2, HIPAA, PCI reports

Phase 3
ML-Based Risk Assessment: Dynamic risk scoring

Predictive Remediation: Proactive issue prevention

Cross-Service Dependencies: Understand service relationships

Cost Optimization: Remediate cost-related issues